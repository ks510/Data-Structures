/**
 * LinkedList: a basic implementation of a singly linked list data structure. 
 * A linked list is a chain of ListNode objects. The head of the list is the 
 * first node of the chain (or null in the case of an empty list).
**/
import java.util.NoSuchElementException;

public class LinkedList
{
    // a linked list has a head node and a size
    private ListNode head;
    private int size;
    private ListNode header;

    /**
     * Construct a new empty list
     */
    public LinkedList() {
        header = new ListNode(null, head);
        head = null;
        size = 0;
    }

    /**
     * Add a new item as the first element
     * @param ListNode node
     */
    public void addFirst(ListNode node) {
        node.setNext(head);
        head = node;
        header.setNext(head);
        ++size;
    }

    /**
     * Remove the first list item
     */
    public void removeFirst() {
        // report error if list empty
        if (head == null) {
            throw new NoSuchElementException();
        } 
        // otherwise remove the item
        else {
            ListNode temp = head;
            head = head.getNext();
            temp.setNext(null);

            header.setNext(head);

            size--;
        }
    }

    /**
     * Add new data to the front of the list by constructing a new node
     */
    //construct new node with Object data and null pointer
    //set new node as head (invoke addFirst(node))
    //increment size (handled by addFirst)!!!
    public void add(Object item) {
        ListNode n = new ListNode(item, null);
        addFirst(n);
    }

    /**
     * Searches the list for the specified item and returns true if found, otherwise false
     * @return True if item is in list, false otherwise
     */
    //first check if the list is empty - return false immediately if empty
    //search the list by comparing each node data
    //create a getData() method to access data in list nodes
    //iterator required due to unindexed list
    //use a for loop to compare the data
    //could use a boolean variable 'found'
    //final statement - return found
    public boolean contains(Object item) {
        boolean found = false;
        if (size == 0) {
            return found;
        } else {
            ListNode compare = head;

            //iterates through the whole list
            for(int i = 1; i < size; i++) {
                //equality check
                if (compare.getData() == item) {
                    found = true;
                }
                compare = compare.getNext();
            }
            return found;
        }
    }

    /**
     * Remove the nth element in the list
     */
    //first check if n is within bounds - error?
    //find the node BEFORE and AFTER nth node to change pointers
    //for loop - increment iterator until the node before nth node (n - 1)
    //find and assign all 3 nodes (BEFORE, nth, AFTER) to a variable for reference
    //change BEFORE and AFTER next ListNode pointers
    //change nth next pointer to null
    //add an empty header node?

    public void remove(int n) {
        if (n > size) {
            System.out.println("Out of bounds.");
        } else if (n == 1) {
            removeFirst();
        } else {
            ListNode prev = header;
            for(int i = 1; i < n; i++) {
                prev = prev.getNext();
            }
            ListNode nth = prev.getNext();
            ListNode after = nth.getNext();

            prev.setNext(after);
            nth.setNext(null);
            --size;
        }
    }

    /**
     * Add a new item as a new ListNode to the nth position in the list
     * @param n position to add new element
     * @param item new data element to add
     */
    //first check if n is within bounds - error?
    //if n is 1, use addFirst()
    //create a new ListNode with item and null pointer
    //for loop - iterate until the node BEFORE nth node (n - 1)
    //find and assign 2 nodes (BEFORE and AFTER nth position) to a variable for reference
    //change BEFORE pointer to nth node, change nth node pointer to AFTER node
    //increment size

    public void addAt(int n, Object item) {
        if (n > size) {
            System.out.println("Out of bounds.");
        } else if (n == 1) {
            add(item);
        } else {
            ListNode prev = header;
            for(int i = 1; i < n; i++) {
                prev = prev.getNext();
            }
            ListNode nth = new ListNode(item, null);
            ListNode after = prev.getNext();
            //change pointers
            prev.setNext(nth);
            nth.setNext(after);
            size++;
        }
    }

    /**
     * Returns a list of all the current items in reverse order
     * @return LinkedList of items in reverse order
     */
    //create a new empty list to store items in reverse order
    //check if current list is empty
    //for loop - iterate down the list until last node
    //create local variables to store/copy list items
    //for each element in the list, add it to the head of the new list
    //increment size? (handled by add method!!!)
    public LinkedList reverse() {
        LinkedList reverseList = new LinkedList();

        if (size == 0) {
            return reverseList;
        } else {
            ListNode copy = header;
            for(int i = 0; i < size; i++) {
                copy = copy.getNext();
                reverseList.add(copy.getData());
            }
        }
        return reverseList;
    }

}
